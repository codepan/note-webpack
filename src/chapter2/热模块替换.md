页面上面的动态DOM变化了，webpack-dev-server会刷新页面，样式文件改变了，页面也会刷新。

但是有时候我们改变了样式文件，希望浏览器值更新样式就行，之前渲染出来的DOM不要动，为了实现这样的需求，webpack-dev-server就不能自动刷新页面了，因为刷新页面，动态生成的DOM就会丢失

```js
const webpack = require('webpack')
module.exports = {
  devServer: {
    hot: true // 打开HMR功能
  },
  plugins: [
    new webpack.HotModuleReplacementPlugin()
  ]
}
```
```js
// index.js
import './style.css'
```

通过以上简单的配置，我们现在修改style.css样式文件中的任意样式，webpack-dev-server会自动打包，然后浏览器并不会重新刷新页面，而是HMR功能让浏览器只重新加载了样式文件

看似一切美好，下面我们来看另一种情况

创建一个新的js文件，名字叫做counter.js
```js
// counter.js
const counter = () => {
  let div = document.createElement('div')
  div.setAttribute('id', 'counter')
  div.innerText = 1
  div.addEventListener('click', () => {
    div.innerText = Number.parseInt(div.innerText, 10) + 1
  })

  document.body.appendChild(div)
}

export default counter
```
再创建一个js文件，名字为number.js
```js
// number.js
const number = () => {
  let div = document.createElement('div')
  div.setAttribute('id', 'number')
  div.innerText = 100
  document.body.appendChild(div)
}

export default counter
```

```js
// index.js
import counter from './counter'
import number from './number'
counter()
number()
```

现在我们点击页面上由counter.js文件生成的那个数字，每点击一次，数字会加1，当点击到10时，停下来，我们再将number.js文件中100修改为200，我们会发现页面刷新了，之前我们辛苦加到10的数字竟然又变成了1

上面的现象感觉HMR并没有生效，这是什么原因呢？这是因为我们没有正确的使用HMR导致的，我们还需要做一些工作
```js
// index.js
import counter from './counter'
import number from './number'
counter()
number()

if (module.hot) {
  module.hot.accept('./number', () => {
    let number = document.getElementById('number')
    document.body.removeChild(number)
    number()
  })
}
```

和之前的修改样式文件，我们做一个对比，为什么样式文件不用写上面那段js代码，HMR就能够生效，而如果是js文件，HMR就要自己再编写一段代码呢？

其实引入css文件，也需要写上面那段代码，只是因为处理css文件咱们使用了css-loader，这个loader内部已经帮咱们写好了上面那段代码而已

不仅如此，其实好多loader中都内置了如上那段代码