```js
// a.js
console.log('a~~~~~~~~')

// b.js
console.log('b~~~~~~~~~~')

// index.js
import './a'
import './b'
console.log('index.js~~~~~~')

// other.js
import './a'
import './b'

console.log('other.js~~~~~~')
```

```js
// webpack.config.js
const path = require('path')

module.exports = {
  entry: {
    index: './src/index.js',
    other: './src/other.js'
  },
  output: {
    filename: '[name].js',
    path: path.resolve(__dirname, 'dist')
  },
  ...
  optimization: {
    splitChunks: { // 分割代码块
      cacheGroups: { // 缓存组
        common: { // 公共的模块，定义什么样的代码需要抽离成单独的模块
          chunks: 'initial',
          minSize: 0, // 最小的大小
          minChunks: 2 // 最小被引用的次数 当为引用2次及以上时
        }
      }
    }
  }
}
```

a.js和b.js分别在index.js中和other.js中各引用了一次，所以a.js和b.js被引用了两次，符合上面配置的提取公共代码的要求，最后会产出三个文件
```js
// common~index~other.js
// index.js
// other.js
```


另外一种情况，index.js中引入了一次jquery，other.js中也引入了一次jquery，这样jquery就被引用了两次，也符合提取公共代码的要求，但是现在jquery是第三方类库，我们并不希望把第三方类库也抽离到
咱们自己的公共代码中，我们想将第三方类库单独抽离成一个文件

```js
// index.js
import './a'
import './b'

console.log('index.js~~~~~~')

import $ from 'jquery'
console.log($)

// other.js
import './a'
import './b'

console.log('other.js~~~~~~')

import $ from 'jquery'
console.log($)
```
```js
// webpack.config.js
const path = require('path')

module.exports = {
  entry: {
    index: './src/index.js',
    other: './src/other.js'
  },
  output: {
    filename: '[name].js',
    path: path.resolve(__dirname, 'dist')
  },
  ...
  optimization: {
    splitChunks: { // 分割代码块
      cacheGroups: { // 缓存组
        common: { // 公共的模块，定义什么样的代码需要抽离成单独的模块
          chunks: 'initial',
          minSize: 0, // 最小的大小
          minChunks: 2 // 最小被引用的次数 当为引用2次及以上时
        },
        vendor: { // 第三方
          priority: 1, // 权重，先抽离该代码块
          test: /node_modules/,
          chunks: 'initial',
          minSize: 0, // 最小的大小
          minChunks: 2 // 最小被引用的次数 当为引用2次及以上时
        }
      }
    }
  }
}
```
